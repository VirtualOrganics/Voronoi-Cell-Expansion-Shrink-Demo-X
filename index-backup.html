<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Cell Expansion-Shrink Demo X</title>
    <!-- Physics-based expansion demo -->
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: 320px;
            transition: all 0.3s ease;
        }
        #controls-content {
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .control-group {
            margin: 8px 0;
        }
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .control-row .control-group {
            flex: 1;
            margin: 0;
        }
        label {
            display: inline-block;
            width: 110px;
            font-size: 13px;
        }
        .control-row label {
            width: 80px;
        }
        input[type="number"] {
            width: 55px;
        }
        input[type="color"] {
            width: 30px;
            height: 25px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .section-header {
            font-weight: bold;
            margin: 15px 0 8px 0;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #controls-toggle {
            background: #007bff;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        #controls-toggle:hover {
            background: #0056b3;
        }
        #controls.hidden {
            width: auto;
            padding: 12px 16px;
        }
        #controls.hidden .section-header {
            margin: 0;
        }
        #controls.hidden #controls-toggle {
            padding: 8px 16px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>

    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
            <div class="section" id="main-controls">
                <div class="section-header">Expansion-Shrink-Demo-X</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Points:</label>
                        <input type="number" id="numPoints" value="100" min="4" max="2500" step="1">
                    </div>
                    <div class="control-group">
                        <label>Min Dist:</label>
                        <input type="number" id="minDistance" value="0.05" min="0.01" max="0.2" step="0.01">
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-group">
                        <label>Periodic:</label>
                        <input type="checkbox" id="periodicMode" checked>
                    </div>
                    <div class="control-group">
                        <label>Ghost Cells:</label>
                        <input type="checkbox" id="showGhostCells">
                    </div>
                    <div class="control-group">
                        <label>MIC:</label>
                        <input type="checkbox" id="useMIC">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Background:</label>
                        <input type="color" id="backgroundColor" value="#333333">
                    </div>
                    <div class="control-group">
                        <label>Boundary:</label>
                        <input type="checkbox" id="showBoundary">
                    </div>
                    <div class="control-group">
                        <label>Poisson:</label>
                        <input type="checkbox" id="poissonSampling" checked>
                    </div>
                </div>
            </div>
            
            <div class="section" id="visualization-controls">
                <div class="section-header">Delaunay Triangles / Tetrahedra</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Vertices:</label>
                        <input type="checkbox" id="showVertices">
                    </div>
                    <div class="control-group">
                        <label>Delaunay:</label>
                        <input type="checkbox" id="showDelaunay">
                    </div>
                    <div class="control-group">
                        <label>Tetrahedra:</label>
                        <input type="checkbox" id="showTetrahedra">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Size:</label>
                        <input type="number" id="delaunaySize" value="0.008" min="0.005" max="0.05" step="0.001">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="vertexColor" value="#ffffff">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="delaunayEdgeColor" value="#FFF700">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Tetra Color:</label>
                        <input type="color" id="tetraColor" value="#888888">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="tetraOpacity" value="0.01" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>
                
                <div class="section-header">Voronoi Diagrams</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Vertices:</label>
                        <input type="checkbox" id="showVoronoiVertices">
                    </div>
                    <div class="control-group">
                        <label>Edges:</label>
                        <input type="checkbox" id="showVoronoiEdges">
                    </div>
                    <div class="control-group">
                        <label>Faces:</label>
                        <input type="checkbox" id="showVoronoiFaces">
                    </div>

                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Size: <span id="voronoiSizeValue">0.0025</span></label>
                        <input type="range" id="voronoiSize" min="0" max="0.0495" value="0.0475" step="0.0005" data-reversed="true">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiVertexColor" value="#bbbbbb">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="voronoiEdgeWidth" value="3" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiEdgeColor" value="#000000">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Face Color:</label>
                        <input type="color" id="voronoiFaceColor" value="#C8C8C8">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="voronoiFaceOpacity" value="0.1" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>



                <!-- Expansion-Shrink Demo Controls -->
                <div class="section-header">Expansion-Shrink Demo</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Live Update:</label>
                        <input type="checkbox" id="liveUpdate">
                    </div>
                    <div class="control-group">
                        <label>Update Step:</label>
                        <input type="number" id="updateStep" value="2" min="1" max="100" step="1" style="width: 60px;">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Active Cell:</label>
                        <input type="number" id="centralCellIndex" value="82" min="-1" step="1" style="width: 60px;">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label>Change:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="color: #0066ff;">âˆ’</span>
                            <input type="range" id="expansionSlider" min="-10" max="10" step="0.01" value="-2" 
                                   style="flex: 1; background: linear-gradient(to right, #0066ff 0%, #666 50%, #ff3333 100%);">
                            <span style="color: #ff3333;">+</span>
                            <span id="expansionValue" style="min-width: 50px; text-align: center; font-weight: bold; color: #0066ff;">-2.00</span>
                        </div>
                    </div>
                </div>
                <div class="control-row">
                    <button id="resetDemo">Reset</button>
                    <button id="selectCentral">Random</button>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label>Selection:</label>
                        <input type="range" id="centralCellOpacity" min="0.0" max="1.0" step="0.01" value="0.8" style="width: 150px;">
                        <span id="centralCellOpacityValue" style="margin-left: 10px;">0.80</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label>Unselected:</label>
                        <input type="range" id="otherCellsOpacity" min="0.0" max="1.0" step="0.01" value="0.2" style="width: 150px;">
                        <span id="otherCellsOpacityValue" style="margin-left: 10px;">0.20</span>
                    </div>
                </div>



                
                <button id="regenerate">Generate New Points</button>
                <button id="recompute">Recompute Triangulation</button>
                <div id="status" class="status"></div>

            </div>
        </div>
    </div>
    
    <script src="dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { DelaunayComputation } from './src/js/DelaunayComputation.js';
        import * as GeometryAnalysis from './src/js/GeometryAnalysis.js';
        import * as Visualizer from './src/js/Visualizer.js';
        import { runGeometryAnalysisTests } from './test/GeometryAnalysis.test.js';
        import { parallelAcutenessAnalysis } from './src/js/WorkerManager.js';
        import { FastAcutenessAnalyzer } from './src/js/FastAcuteness.js';
        import { GrowthSystem } from './src/js/GrowthSystem.js';
        import { PhysicsExpansion } from './src/js/PhysicsExpansion.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiVerticesGroup, voronoiEdgesGroup, tetrahedraGroup, boundaryGroup, voronoiFacesGroup;
        let mainCellGroup, ghostCellsGroup; // NEW: Groups for ghost cell tiling
        let Module;
        let currentPoints = [];
        let computation = null;
        let fastAnalyzer = null;
        let growthSystem = null;
        let physicsEngine = null;
        let velocities = [];
        let frameCount = 0;
        let growthEnabled = false;
        
        // Demo mode variables
        let demoMode = true; // Always in demo mode
        let centralCellIndex = 82;
        let generatorMeshes = [];
        let vectorArrows = [];
        let originalPositions = [];
        
        // ACUTENESS ANALYSIS: Global variables for analysis results
        let analysisResults = null;
        let savedLegendOpacities = {}; // Store opacity settings globally to persist across updates
        let lastAnalysisTime = 0;
        const ANALYSIS_THROTTLE_MS = 100; // Minimum time between analyses

        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc); // Light grey background
            
            // Initialize physics engine for expansion-shrink demo
            physicsEngine = new PhysicsExpansion();
            physicsEngine.forceStrength = 2.0;  // Increased for more visible effect
            physicsEngine.damping = 0.9;
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiVerticesGroup = new THREE.Group();
            voronoiEdgesGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            
            // NEW: Ghost cell groups
            mainCellGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            
            // Add main cell groups to the main cell container
            mainCellGroup.add(verticesGroup);
            mainCellGroup.add(delaunayGroup);
            mainCellGroup.add(voronoiVerticesGroup);
            mainCellGroup.add(voronoiEdgesGroup);
            mainCellGroup.add(tetrahedraGroup);
            mainCellGroup.add(voronoiFacesGroup);
            
            scene.add(mainCellGroup);
            scene.add(boundaryGroup); // Boundary stays separate
            scene.add(ghostCellsGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update resolution for LineMaterial
            delaunayGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            voronoiVerticesGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            voronoiEdgesGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers to boundary group so they hide together
            const axesHelper = new THREE.AxesHelper(0.2);
            boundaryGroup.add(axesHelper);
            
            // Hide boundary by default
            boundaryGroup.visible = false;
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01;
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin),
                    margin + Math.random() * (1 - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking`);
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [Math.random(), Math.random(), Math.random()];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }

        // NEW: Simple line functions for better performance (width parameter kept for compatibility)
        function createDelaunayEdgesThick(computation, width, material) {
            const delaunayEdgeSet = new Set();
            const positions = [];

            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }

            if (positions.length === 0) return;

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            delaunayGroup.add(line);
        }

        function createVoronoiEdgesThick(computation, width, material) {
            if (computation.voronoiEdges.length === 0) return;
            
            const positions = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2[0], p2[1], p2[2]);
                }
            }

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            voronoiEdgesGroup.add(line);
        }

        // NEW: MIC-based edge drawing function (Phase 2 implementation)
        function createDelaunayEdgesMIC(computation) {
            const points = [];
            const delaunayEdgeSet = new Set();
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }

        // NEW: Enhanced Voronoi edge drawing with MIC
        function createVoronoiEdgesMIC(computation) {
            if (computation.voronoiEdges.length === 0) return null;
            
            const points = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2[0], p2[1], p2[2]);
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }



        // NEW: Ghost Cell Tiling (Phase 3 implementation)
        function createGhostCellTiling() {
            ghostCellsGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                }
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            ghostCellsGroup.clear();
            
            if (!computation || !document.getElementById('showGhostCells').checked) {
                return;
            }
            
            console.log("Creating ghost cell tiling...");
            
            // Define the 26 neighboring cell positions (excluding center at [0,0,0])
            const ghostOffsets = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x !== 0 || y !== 0 || z !== 0) { // Skip center cell
                            ghostOffsets.push([x, y, z]);
                        }
                    }
                }
            }
            
            // Semi-transparent materials for ghost cells
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const ghostDelaunayMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayEdgeColorInt, 
                opacity: 0.3, 
                transparent: true 
            });
            
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const ghostVoronoiMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt, 
                opacity: 0.2, 
                transparent: true
            });
            
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            const ghostVertexMaterial = new THREE.MeshPhongMaterial({ 
                color: vertexColorInt, 
                opacity: 0.4, 
                transparent: true 
            });
            
            // Create ghost geometries
            const delaunayGeometry = createDelaunayEdgesMIC(computation);
            const voronoiGeometry = createVoronoiEdgesMIC(computation);
            
            // Create ghost cells for each offset
            for (const [offsetX, offsetY, offsetZ] of ghostOffsets) {
                const ghostGroup = new THREE.Group();
                ghostGroup.position.set(offsetX, offsetY, offsetZ);
                
                // Add Delaunay edges
                if (delaunayGeometry && document.getElementById('showDelaunay').checked) {
                    const ghostDelaunayLines = new THREE.LineSegments(
                        delaunayGeometry.clone(), 
                        ghostDelaunayMaterial
                    );
                    ghostGroup.add(ghostDelaunayLines);
                }
                
                // Add Voronoi edges
                if (voronoiGeometry && document.getElementById('showVoronoiEdges').checked) {
                    const ghostVoronoiLines = new THREE.LineSegments(
                        voronoiGeometry.clone(), 
                        ghostVoronoiMaterial
                    );
                    ghostGroup.add(ghostVoronoiLines);
                }
                
                // Add Voronoi faces with same random coloring as main cell
                if (document.getElementById('showVoronoiFaces').checked && computation.tetrahedra.length > 0) {
                    // Get face color from input
                    const faceColorHex = document.getElementById('voronoiFaceColor').value;
                    const faceColorInt = parseInt(faceColorHex.substring(1), 16);
                    const baseOpacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
                    const opacity = baseOpacity * 0.3; // More transparent for ghost
                    
                    // Create ghost Voronoi cells
                    const cells = new Map();
                    computation.tetrahedra.forEach((tet, index) => {
                        const barycenter = computation.barycenters[index];
                        if (!barycenter) return;

                        tet.forEach(vertexIndex => {
                            if (!cells.has(vertexIndex)) {
                                cells.set(vertexIndex, []);
                            }
                            cells.get(vertexIndex).push(new THREE.Vector3(...barycenter));
                        });
                    });

                    cells.forEach((cellVertices, vertexIndex) => {
                        if (cellVertices.length < 4) return;

                        const geometry = new ConvexGeometry(cellVertices);
                        
                        // Default ghost material
                        const material = new THREE.MeshPhongMaterial({
                            color: faceColorInt,
                            opacity: opacity,
                            transparent: true,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        ghostGroup.add(mesh);
                    });
                }
                
                // Add vertices
                if (document.getElementById('showVertices').checked) {
                    const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
                    const sphereGeometry = new THREE.SphereGeometry(vertexSize, 8, 8);
                    
                    for (const point of computation.pointsArray) {
                        const sphere = new THREE.Mesh(sphereGeometry, ghostVertexMaterial);
                        sphere.position.set(point[0], point[1], point[2]);
                        ghostGroup.add(sphere);
                    }
                }
                
                ghostCellsGroup.add(ghostGroup);
            }
            
            console.log(`Created ${ghostOffsets.length} ghost cells`);
        }

        // Legacy boundary clipping approach (for comparison)
        function drawMeshesLegacy(computation, delaunayMaterial, voronoiMaterial) {
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayMaterial.color, 
                opacity: 0.6, 
                transparent: true 
            });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiMaterial.color, 
                opacity: 0.8, 
                transparent: true 
            });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges with Legacy Clipping ---
            const delaunayEdgeSet = new Set();
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2min = getMinimumImage(p1, p2);
                            const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                            
                            if (isPeriodic) {
                                periodicEdgeCount++;
                                // OLD: Boundary clipping approach
                                for (let dim = 0; dim < 3; dim++) {
                                    const diff = p2[dim] - p1[dim];
                                    if (Math.abs(diff) > 0.5) {
                                        const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                        const tClamped = Math.max(0.001, Math.min(0.999, t));
                                        
                                        const midPoint = [
                                            p1[0] + tClamped * (p2[0] - p1[0]),
                                            p1[1] + tClamped * (p2[1] - p1[1]),
                                            p1[2] + tClamped * (p2[2] - p1[2])
                                        ];
                                        midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                        
                                        // Draw first segment to boundary
                                        const geom1 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...p1),
                                            new THREE.Vector3(...midPoint)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom1, delaunayPeriodicMaterial));
                                        
                                        // Draw second segment from opposite boundary
                                        const oppositePoint = [...midPoint];
                                        oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                        const geom2 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...oppositePoint),
                                            new THREE.Vector3(...p2)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom2, delaunayPeriodicMaterial));
                                        break;
                                    }
                                }
                            } else {
                                regularEdgeCount++;
                                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                                ]);
                                delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                            }
                        } else {
                            const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                            ]);
                            delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                        }
                    }
                }
            }
            
            // --- Draw Voronoi Edges with Legacy Clipping ---
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2min = getMinimumImage(p1, p2);
                    const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                    
                    if (isPeriodic) {
                        for (let dim = 0; dim < 3; dim++) {
                            const diff = p2[dim] - p1[dim];
                            if (Math.abs(diff) > 0.5) {
                                const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                const tClamped = Math.max(0.001, Math.min(0.999, t));
                                
                                const midPoint = [
                                    p1[0] + tClamped * (p2[0] - p1[0]),
                                    p1[1] + tClamped * (p2[1] - p1[1]),
                                    p1[2] + tClamped * (p2[2] - p1[2])
                                ];
                                midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                
                                const geom1 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1),
                                    new THREE.Vector3(...midPoint)
                                ]);
                                voronoiEdgesGroup.add(new THREE.Line(geom1, voronoiPeriodicMaterial));
                                
                                const oppositePoint = [...midPoint];
                                oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                const geom2 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...oppositePoint),
                                    new THREE.Vector3(...p2)
                                ]);
                                voronoiEdgesGroup.add(new THREE.Line(geom2, voronoiPeriodicMaterial));
                                break;
                            }
                        }
                    } else {
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                        ]);
                        voronoiEdgesGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                    }
                } else {
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                    ]);
                    voronoiEdgesGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                }
            }
            
            console.log(`Legacy: Drew ${periodicEdgeCount} periodic edges (clipped), ${regularEdgeCount} regular edges`);
        }

        // Visualize vertices
        function drawVertices(computation) {
            // Dispose of old geometries and materials
            verticesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            verticesGroup.clear();
            
            // Only draw if checkbox is checked
            if (!document.getElementById('showVertices').checked) return;
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            
            const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: vertexColorInt });
            
            if (computation.isPeriodic) {
                // In periodic mode: show original vertices + periodic copies that contribute to visible cells
                const shownVertices = new Set();
                
                // First, show all original vertices
                for (let i = 0; i < computation.pointsArray.length; i++) {
                    const point = computation.pointsArray[i];
                    const key = `${point[0].toFixed(6)},${point[1].toFixed(6)},${point[2].toFixed(6)}`;
                    if (!shownVertices.has(key)) {
                        shownVertices.add(key);
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(point[0], point[1], point[2]);
                        verticesGroup.add(sphere);
                    }
                }
                
                // Then, for cells that extend beyond boundaries, show periodic copies of vertices
                const cells = new Map();
                computation.tetrahedra.forEach((tet, index) => {
                    const barycenter = computation.barycenters[index];
                    if (!barycenter) return;

                    tet.forEach(vertexIndex => {
                        if (!cells.has(vertexIndex)) {
                            cells.set(vertexIndex, []);
                        }
                        cells.get(vertexIndex).push(barycenter);
                    });
                });
                
                // For each cell, if barycenters extend beyond [0,1], show periodic vertex copies
                cells.forEach((cellBarycenters, vertexIndex) => {
                    if (vertexIndex >= computation.pointsArray.length) return;
                    
                    const hasExternalBarycenter = cellBarycenters.some(b => 
                        b[0] < 0 || b[0] > 1 || b[1] < 0 || b[1] > 1 || b[2] < 0 || b[2] > 1
                    );
                    
                    if (hasExternalBarycenter) {
                        const originalVertex = computation.pointsArray[vertexIndex];
                        
                        // Show periodic copies in all 27 positions
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    if (dx === 0 && dy === 0 && dz === 0) continue; // Skip original
                                    
                                    const periodicVertex = [
                                        originalVertex[0] + dx,
                                        originalVertex[1] + dy,
                                        originalVertex[2] + dz
                                    ];
                                    
                                    const key = `${periodicVertex[0].toFixed(6)},${periodicVertex[1].toFixed(6)},${periodicVertex[2].toFixed(6)}`;
                                    if (!shownVertices.has(key)) {
                                        shownVertices.add(key);
                                        const sphere = new THREE.Mesh(geometry, material);
                                        sphere.position.set(periodicVertex[0], periodicVertex[1], periodicVertex[2]);
                                        verticesGroup.add(sphere);
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                // In non-periodic mode: show only original vertices
                for (const point of computation.pointsArray) {
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(point[0], point[1], point[2]);
                    verticesGroup.add(sphere);
                }
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(computation) {
            delaunayGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const edgeSet = new Set();
            const material = new THREE.LineBasicMaterial({ color: 0x0066ff });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0099ff
            });
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]],
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        
                        // Get vertex positions
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        // Check if edge crosses periodic boundary
                        const isPeriodic = computation._isPeriodicEdge(p1, p2);
                        
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            p1[0], p1[1], p1[2],
                            p2[0], p2[1], p2[2]
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const line = new THREE.Line(
                            geometry, 
                            isPeriodic ? periodicMaterial : material
                        );
                        delaunayGroup.add(line);
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiVerticesGroup.clear();
            voronoiEdgesGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            // Get edge color
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiEdgesGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiSizeSliderValue = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexSize = 0.05 - voronoiSizeSliderValue; // Convert from reversed slider
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiVerticesGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces with default styling
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.clear();
            
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            // Get face color and opacity from inputs
            const faceColorHex = document.getElementById('voronoiFaceColor').value;
            const faceColorInt = parseInt(faceColorHex.substring(1), 16);
            const faceOpacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            // Default material - light grey (200,200,200) with 10% opacity
            const defaultMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(200/255, 200/255, 200/255), // Always light grey
                opacity: 0.1, // Always 10% opacity
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the barycenters of tetrahedra that contain it
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const barycenter = computation.barycenters[index];
                if (!barycenter) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(barycenter); // Store as array, not THREE.Vector3 yet
                });
            });

            // For each cell, compute the convex hull
            let cellIndex = 0;
            
            // Debug: log first few cells to understand the issue
            // Cell drawing
            cells.forEach((cellBarycenters, vertexIndex) => {
                if (cellBarycenters.length < 4) return; // Need at least 4 points for a 3D shape

                // Apply MIC correction for periodic cells to prevent transverse connections
                let vertices;
                if (computation.isPeriodic && cellBarycenters.length > 0) {
                    // Apply MIC: Use first barycenter as reference, correct others to same periodic image
                    const reference = cellBarycenters[0];
                    vertices = cellBarycenters.map(barycenter => {
                        if (barycenter === reference) {
                            return new THREE.Vector3(...reference);
                        }
                        
                        // Apply MIC to bring barycenter to same periodic image as reference
                        const corrected = getMinimumImage(reference, barycenter);
                        return new THREE.Vector3(...corrected);
                    });
                    

                } else {
                    // Non-periodic: use barycenters as-is
                    vertices = cellBarycenters.map(barycenter => 
                        new THREE.Vector3(...barycenter)
                    );
                }
                
                try {
                    // Create a convex geometry from the vertices of the Voronoi cell
                    const geometry = new ConvexGeometry(vertices);
                    const material = defaultMaterial.clone();
                    
                    // If this is the central cell, make it darker grey
                    if (vertexIndex === centralCellIndex) {
                        material.color.setRGB(0.4, 0.4, 0.4); // Darker grey for central cell
                        material.opacity = parseFloat(document.getElementById('centralCellOpacity').value);
                    } else {
                        material.opacity = parseFloat(document.getElementById('otherCellsOpacity').value);
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.cellIndex = vertexIndex; // Store the vertex index as cell index
                    voronoiFacesGroup.add(mesh);
                    cellIndex++;
                } catch (error) {
                    // Skip cells that can't form valid convex geometry
                    console.warn(`Skipped Voronoi cell ${vertexIndex}: ${error.message}`);
                }
            });
            
            console.log(`Drew ${cellIndex} Voronoi cells ${computation.isPeriodic ? '(with MIC correction)' : '(non-periodic)'}`);
        }
        
        // NEW: Unified mesh drawing function with MIC toggle
        function drawMeshes(computation) {
            // Dispose of old geometries and materials to prevent memory leaks
            delaunayGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiVerticesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiEdgesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            delaunayGroup.clear();
            voronoiVerticesGroup.clear();
            voronoiEdgesGroup.clear();
            voronoiFacesGroup.clear();

            const useMIC = document.getElementById('useMIC').checked;
            
            // Toggle UI based on MIC mode
            document.getElementById('delaunayEdgeWidth').disabled = !useMIC;
            document.getElementById('voronoiEdgeWidth').disabled = !useMIC;

            if (useMIC) {
                // --- Draw using Thick Line (MIC) mode ---
                const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
                const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
                const delaunayEdgeWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
                const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
                createDelaunayEdgesThick(computation, delaunayEdgeWidth, delaunayMaterial);

                const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
                const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
                const voronoiEdgeWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
                const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt });
                createVoronoiEdgesThick(computation, voronoiEdgeWidth, voronoiMaterial);

            } else {
                // --- Draw using Normal, Thin Line mode ---
                const delaunayGeom = createDelaunayEdgesMIC(computation);
                if (delaunayGeom) {
                    const delaunayMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('delaunayEdgeColor').value });
                    delaunayGroup.add(new THREE.LineSegments(delaunayGeom, delaunayMaterial));
                }

                const voronoiGeom = createVoronoiEdgesMIC(computation);
                if (voronoiGeom) {
                    const voronoiMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('voronoiEdgeColor').value });
                    voronoiEdgesGroup.add(new THREE.LineSegments(voronoiGeom, voronoiMaterial));
                }
            }
            
            // Voronoi vertices are drawn separately
            const voronoiSizeSliderValue = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexSize = 0.05 - voronoiSizeSliderValue; // Convert from reversed slider
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiVerticesGroup.add(sphere);
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                let vertices = tet.map(i => computation.pointsArray[i]);
                
                // Apply MIC correction for periodic tetrahedra
                if (computation.isPeriodic && vertices.length === 4) {
                    // Use first vertex as reference for MIC
                    const reference = vertices[0];
                    vertices = vertices.map((vertex, index) => {
                        if (index === 0) return vertex;
                        
                        // Apply MIC to bring vertex to same periodic image as reference
                        const corrected = [...vertex];
                        for (let i = 0; i < 3; i++) {
                            const delta = vertex[i] - reference[i];
                            if (delta > 0.5) {
                                corrected[i] -= 1.0;
                            } else if (delta < -0.5) {
                                corrected[i] += 1.0;
                            }
                        }
                        return corrected;
                    });
                }
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // Compute Delaunay-Voronoi
        async function computeDelaunayVoronoi() {
            if (!Module) return;
            
            // Add a small delay for live updates to prevent crashes
            if (document.getElementById('liveUpdate') && document.getElementById('liveUpdate').checked) {
                await new Promise(resolve => setTimeout(resolve, 16)); // ~60 FPS
            }

            // Diagnostic check for corrupt input data
            console.log("--- New Computation Triggered ---");
            console.log(`Checking ${currentPoints.length} points before sending to WASM.`);
            let outliersFound = 0;
            for (const p of currentPoints) {
                if (!p || p.length !== 3 || p[0] < 0 || p[0] > 1 || p[1] < 0 || p[1] > 1 || p[2] < 0 || p[2] > 1) {
                    console.error("ðŸ”´ OUTLIER DETECTED! This point is outside the [0, 1] unit cube and will corrupt the periodic triangulation:", p);
                    outliersFound++;
                }
            }
            if (outliersFound > 0) {
                console.error(`Found ${outliersFound} outlier points. Halting computation.`);
                setStatus(`Error: Found ${outliersFound} outlier points.`, false);
                return; // Stop execution if data is bad
            }
            console.log("âœ… Point data is clean. Proceeding with computation...");
            
            const isPeriodic = document.getElementById('periodicMode').checked;
            
            setStatus('Computing...', false);
            
            try {
                // Create computation instance
                computation = new DelaunayComputation(currentPoints, isPeriodic);
                
                // Run the computation
                await computation.compute(Module);
                
                // Get statistics
                const stats = computation.getStats();
                setStatus(`Success! ${stats.numTetrahedra} tetrahedra, ${stats.numVoronoiEdges} Voronoi edges`, true);
                
                // Update visualization
                drawVertices(computation);
                drawMeshes(computation);
                drawTetrahedra(computation);
                drawVoronoiFaces(computation); // Ensure this is called
                
                // Update central cell color after drawing faces
                updateCentralCellColor();
                
                // NEW: Create ghost cell tiling
                createGhostCellTiling();
                
                // Acuteness analysis removed - not used in expansion demo
                
                updateStats();
                
                // Update demo visualizations
                createGeneratorMeshes();
                createVectorArrows();
                updateCentralCellColor();
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, false);
                console.error(error);
            }
        }
        
        // Update statistics
        function updateStats() {
            if (!computation) return;
            
            const stats = computation.getStats();
            const mode = stats.isPeriodic ? 'Periodic' : 'Non-periodic';
            let statusMessage = `${mode} | ${stats.numPoints} points | ${stats.numTetrahedra} tetrahedra`;
            
            // Add average cell acuteness if cells mode is active or if we have cell scores
            if (analysisResults && analysisResults.cellScores) {
                const avgCellScore = (analysisResults.cellScores.reduce((a, b) => a + b, 0) / analysisResults.cellScores.length).toFixed(1);
                statusMessage += ` | Cell avg: ${avgCellScore}`;
            }
            
            setStatus(statusMessage, true);
        }
        
        // ACUTENESS ANALYSIS: Apply analysis coloring based on checked boxes
        function applyAnalysisColoring() {
            if (!analysisResults || !computation) {
                console.warn('No analysis results available', { analysisResults, computation });
                return;
            }
            
            // Check which analysis modes are active
            const vertexActive = document.getElementById('vertexAnalysis').checked;
            const edgeActive = document.getElementById('edgeAnalysis').checked;
            const faceCellMode = document.getElementById('faceCellMode').value;
            
            console.log('Analysis modes:', { vertexActive, edgeActive, faceCellMode });
            
            // Remove any existing analysis coloring
            Visualizer.removeAnalysisColoring();
            
            // If no analysis is active, restore normal visualization
            if (!vertexActive && !edgeActive && faceCellMode === 'none') {
                console.log('No analysis active - restoring normal visualization');
                // Restore normal Voronoi faces and spheres
                drawVoronoiFaces(computation);
                drawMeshes(computation); // This will restore normal spheres
                return;
            }
            
            // Determine which legends to show
            // Rule: If Faces or Cells is selected, show that legend
            // Otherwise, show Vertices and/or Edges legend if they are checked
            const legendsToShow = [];
            
            if (faceCellMode !== 'none') {
                // Faces or Cells is selected - show only that legend
                legendsToShow.push(faceCellMode);
            } else {
                // Neither Faces nor Cells - show Vertices/Edges if checked
                if (vertexActive) legendsToShow.push('vertices');
                if (edgeActive) legendsToShow.push('edges');
            }
            
            console.log('Legends to show:', legendsToShow);
            
            const meshGroups = {
                tetrahedraGroup: tetrahedraGroup,
                voronoiFacesGroup: voronoiFacesGroup,
                voronoiVerticesGroup: voronoiVerticesGroup,
                voronoiEdgesGroup: voronoiEdgesGroup
            };
            
            // Apply vertex analysis if checked
            if (vertexActive) {
                console.log('Applying vertex analysis');
                const thickness = parseFloat(document.getElementById('vertexThickness').value);
                Visualizer.applyVertexColoring(scene, meshGroups.voronoiVerticesGroup, analysisResults.vertexScores, computation, thickness);
            }
            
            // Apply edge analysis if checked
            if (edgeActive) {
                console.log('Applying edge analysis');
                const thickness = parseFloat(document.getElementById('edgeThickness').value);
                Visualizer.applyEdgeColoring(scene, meshGroups.voronoiEdgesGroup, analysisResults.edgeScores, computation, thickness);
            }
            
            // Apply face or cell analysis based on dropdown
            if (faceCellMode !== 'none') {
                if (faceCellMode === 'faces') {
                    console.log('Applying face analysis');
                    Visualizer.applyFaceColoring(scene, meshGroups.voronoiFacesGroup, analysisResults.faceScores, computation);
                } else if (faceCellMode === 'cells') {
                    console.log('Applying cell analysis');
                    Visualizer.applyCellColoring(scene, meshGroups.voronoiFacesGroup, analysisResults.cellScores, computation);
                }
            }
            
            // Now handle legend display based on our rules
            // Remove any existing legends first
            const existingLegends = document.querySelectorAll('.acuteness-legend');
            existingLegends.forEach(legend => legend.remove());
            
            // Create appropriate legends
            if (legendsToShow.includes('faces')) {
                Visualizer.createAndShowLegend('FACE', analysisResults.faceScores);
            } else if (legendsToShow.includes('cells')) {
                Visualizer.createAndShowLegend('CELL', analysisResults.cellScores);
            } else {
                // Show vertex/edge legends
                if (legendsToShow.includes('vertices')) {
                    Visualizer.createAndShowLegend('VERTEX', analysisResults.vertexScores);
                }
                if (legendsToShow.includes('edges')) {
                    // For multiple legends, offset them vertically
                    const offset = legendsToShow.includes('vertices') ? 250 : 0;
                    Visualizer.createAndShowLegend('EDGE', analysisResults.edgeScores, offset);
                }
            }
        }
        
        // Set status message
        function setStatus(message, isSuccess) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Legend color and opacity control functions
        
        window.updateLegendOpacityValue = function(index, value) {
            // Update the display value
            const valueSpan = document.getElementById(`legend-opacity-value-${index}`);
            if (valueSpan) {
                valueSpan.textContent = parseFloat(value).toFixed(2);
            }
        };
        
        // ACUTENESS ANALYSIS: Update legend opacities
        window.updateLegendOpacities = function() {
            const opacitySliders = document.querySelectorAll('.acuteness-legend input[type="range"]');
            const opacities = [];
            
            opacitySliders.forEach((slider, index) => {
                opacities.push({
                    min: parseInt(slider.getAttribute('data-range-min')),
                    max: parseInt(slider.getAttribute('data-range-max')),
                    opacity: parseFloat(slider.value)
                });
            });
            
            // Store opacities globally
            window.legendOpacities = opacities;
            window.savedLegendOpacities = opacities; // Save to window object for access from Visualizer.js
            console.log('Updated legend opacities:', opacities);
            
            // Just update the material opacities directly without recreating everything
            if (voronoiFacesGroup && voronoiFacesGroup.children.length > 0) {
                console.log('Updating opacities for', voronoiFacesGroup.children.length, 'meshes');
                console.log('Opacity ranges:', opacities);
                
                // Count how many meshes are in each range
                const rangeCounts = {};
                voronoiFacesGroup.children.forEach(mesh => {
                    if (mesh.userData.score !== undefined) {
                        const score = mesh.userData.score;
                        const range = opacities.find(r => score >= r.min && score <= r.max);
                        if (range) {
                            const key = `${range.min}-${range.max}`;
                            rangeCounts[key] = (rangeCounts[key] || 0) + 1;
                        }
                    }
                });
                console.log('Meshes per range:', rangeCounts);
                
                // Update each mesh's material opacity based on its stored score
                voronoiFacesGroup.children.forEach((mesh, index) => {
                    if (mesh.userData.score !== undefined && mesh.material) {
                        const score = mesh.userData.score;
                        // Find the opacity for this score
                        const opacityRange = opacities.find(range => 
                            score >= range.min && score <= range.max
                        );
                        if (opacityRange) {
                            mesh.material.opacity = opacityRange.opacity;
                            mesh.material.needsUpdate = true;
                        }
                    }
                });
            }
        };
        
        // ACUTENESS ANALYSIS: Update legend colors
        window.updateLegendColors = function(analysisType) {
            if (!analysisType) {
                console.warn('updateLegendColors called without analysisType');
                return;
            }
            
            // Get color inputs for this specific legend
            const legend = document.getElementById(`acuteness-legend-${analysisType.toLowerCase()}`);
            if (!legend) return;
            
            const colorInputs = legend.querySelectorAll('input[type="color"]');
            const colors = [];
            colorInputs.forEach((input, index) => {
                colors[index] = parseInt(input.value.substring(1), 16);
            });
            
            // Store colors specific to this analysis type
            window[`legendCustomColors_${analysisType}`] = colors;
            
            // Reapply coloring
            if (analysisResults) {
                applyAnalysisColoring();
            }
        };
        
        // Demo visualization functions
        function createGeneratorMeshes() {
            // Clear existing meshes
            generatorMeshes.forEach(mesh => scene.remove(mesh));
            generatorMeshes = [];
            
            // Generator meshes disabled - using white vertices instead
            return;
        }
        
        function createVectorArrows() {
            // Clear existing arrows
            vectorArrows.forEach(arrow => scene.remove(arrow));
            vectorArrows = [];
            
            // Vector display removed - no longer showing movement vectors
            return;
            
            const expansionValue = parseFloat(document.getElementById('expansionSlider').value);
            if (Math.abs(expansionValue) < 0.01 || centralCellIndex < 0 || !computation) return;
            
            const point = currentPoints[centralCellIndex];
            if (!point) return;
            
            // Get the cell's Voronoi vertices to calculate centroid (same as in applyDemoExpansion)
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const barycenter = computation.barycenters[index];
                if (!barycenter) return;
                
                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(barycenter);
                });
            });
            
            const cellVertices = cells.get(centralCellIndex);
            if (!cellVertices || cellVertices.length === 0) return;
            
            // Calculate centroid
            let sumX = 0, sumY = 0, sumZ = 0;
            cellVertices.forEach(vertex => {
                sumX += vertex[0];
                sumY += vertex[1];
                sumZ += vertex[2];
            });
            const centroid = [sumX / cellVertices.length, sumY / cellVertices.length, sumZ / cellVertices.length];
            
            // Calculate movement direction
            const direction = new THREE.Vector3(
                point[0] - centroid[0],
                point[1] - centroid[1],
                point[2] - centroid[2]
            );
            
            // Use logarithmic scaling for arrow length to prevent them from getting too big
            const length = Math.log(1 + Math.abs(expansionValue)) * 0.1;
            direction.normalize();
            
            if (expansionValue < 0) {
                direction.multiplyScalar(-1); // Reverse for shrinking
            }
            
            const origin = new THREE.Vector3(point[0], point[1], point[2]);
            const arrowHelper = new THREE.ArrowHelper(
                direction,
                origin,
                length,
                expansionValue > 0 ? 0xff3333 : 0x0066ff,
                length * 0.4,  // Head length
                length * 0.3   // Head width
            );
            
            scene.add(arrowHelper);
            vectorArrows.push(arrowHelper);
        }
        
        function updateCentralCellColor() {
            if (centralCellIndex < 0 || !voronoiFacesGroup) return;
            
            const expansionValue = parseFloat(document.getElementById('expansionSlider').value);
            const centralOpacity = parseFloat(document.getElementById('centralCellOpacity').value);
            const otherOpacity = parseFloat(document.getElementById('otherCellsOpacity').value);
            
            // Update all cell colors
            voronoiFacesGroup.children.forEach((child, index) => {
                if (child.material && child.userData.cellIndex !== undefined) {
                    const cellIdx = child.userData.cellIndex;
                    
                    if (cellIdx === centralCellIndex) {
                        // Central cell - changes color based on expansion
                        if (expansionValue > 0) {
                            // Red for expansion
                            child.material.color.setRGB(1, 0, 0);
                        } else if (expansionValue < 0) {
                            // Blue for shrinking
                            child.material.color.setRGB(0, 0, 1);
                        } else {
                            // Neutral darker grey
                            child.material.color.setRGB(0.4, 0.4, 0.4);
                        }
                        child.material.opacity = centralOpacity;
                        child.material.needsUpdate = true;
                    } else {
                        // Other cells - light grey (200,200,200)
                        child.material.color.setRGB(200/255, 200/255, 200/255);
                        child.material.opacity = otherOpacity;
                        child.material.needsUpdate = true;
                    }
                }
            });
        }
        
        function applyDemoExpansion() {
            if (centralCellIndex < 0 || !originalPositions.length || !computation || !physicsEngine) return;
            
            const expansionValue = parseFloat(document.getElementById('expansionSlider').value);
            
            // Clear all growth rates
            physicsEngine.clearGrowthRates();
            
            // Set growth rate for central cell if not zero
            if (Math.abs(expansionValue) > 0.001) {
                physicsEngine.setGrowthRate(centralCellIndex, expansionValue * 5.0); // Scale up for visible effect
                
                // Get Voronoi cells for physics calculation
                const cells = [];
                for (let i = 0; i < currentPoints.length; i++) {
                    cells.push([]); // Initialize empty cells
                }
                
                // Build cell vertices from tetrahedra barycenters
                computation.tetrahedra.forEach((tet, index) => {
                    const barycenter = computation.barycenters[index];
                    if (!barycenter) return;
                    
                    tet.forEach(vertexIndex => {
                        if (cells[vertexIndex]) {
                            cells[vertexIndex].push(barycenter);
                        }
                    });
                });
                
                // Apply physics step
                const result = physicsEngine.applyPhysicsStep(currentPoints, cells);
                currentPoints = result.updatedPoints;
                
                // Update all mesh positions
                currentPoints.forEach((point, index) => {
                    if (generatorMeshes[index]) {
                        generatorMeshes[index].position.set(point[0], point[1], point[2]);
                    }
                });
            } else {
                // Reset to original positions when slider is at zero
                currentPoints = originalPositions.map(p => [...p]);
                currentPoints.forEach((point, index) => {
                    if (generatorMeshes[index]) {
                        generatorMeshes[index].position.set(point[0], point[1], point[2]);
                    }
                });
                physicsEngine.reset();
            }
            
            // Only recompute if live update is enabled
            if (document.getElementById('liveUpdate') && document.getElementById('liveUpdate').checked) {
                computeDelaunayVoronoi();
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            
            // Apply growth if enabled
            if (growthEnabled && computation && analysisResults) {
                // Apply growth based on acuteness
                const newPoints = growthSystem.applyGrowth(currentPoints, computation, analysisResults);
                
                // Check if points actually changed
                let changed = false;
                for (let i = 0; i < newPoints.length; i++) {
                    if (newPoints[i][0] !== currentPoints[i][0] || 
                        newPoints[i][1] !== currentPoints[i][1] || 
                        newPoints[i][2] !== currentPoints[i][2]) {
                        changed = true;
                        break;
                    }
                }
                
                if (changed) {
                    currentPoints = newPoints;
                    
                    // Update growth statistics display
                    const stats = growthSystem.getStats();
                    // document.getElementById('growthStats').textContent = 
                    //     `Grow: ${stats.growingPoints} | Shrink: ${stats.shrinkingPoints} | Avg Î”: ${stats.averageDisplacement.toFixed(4)} | Max Î”: ${stats.maxDisplacement.toFixed(4)}`;
                    
                    // Recompute if live update is enabled
                    // if (document.getElementById('liveUpdate').checked) {
                    //     const updateFrequency = parseInt(document.getElementById('updateFrequency').value);
                    //     if (frameCount % updateFrequency === 0) {
                    //         computeDelaunayVoronoi();
                    //     }
                    // } else {
                    //     drawVertices(computation);
                    // }
                }
            }

            // Apply continuous expansion/shrink physics if slider is not at zero
            if (document.getElementById('expansionSlider') && 
                Math.abs(parseFloat(document.getElementById('expansionSlider').value)) > 0.001 &&
                document.getElementById('liveUpdate').checked) {
                const updateStep = parseInt(document.getElementById('updateStep').value) || 1;
                if (frameCount % updateStep === 0) {
                    applyDemoExpansion();
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(module => {
            Module = module;
            setStatus('Module loaded', true);
            
            // Initialize the Visualizer module with THREE.js objects
            Visualizer.initVisualizer(THREE, ConvexGeometry);
            
            initThree();
            
            // Generate initial points
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            const usePoisson = document.getElementById('poissonSampling').checked;
            const points = usePoisson ? 
                generatePoissonPoints(numPoints, minDist) : 
                generateWellDistributedPoints(numPoints, minDist);
            currentPoints = points;

            // Initialize velocities
            velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
            
            // Set initial checkbox states BEFORE computation
            document.getElementById('showVertices').checked = true;
            document.getElementById('showDelaunay').checked = true;
            document.getElementById('showTetrahedra').checked = false;
            document.getElementById('showVoronoiVertices').checked = false;
            document.getElementById('showVoronoiEdges').checked = false;
            document.getElementById('showVoronoiFaces').checked = true;
            document.getElementById('showBoundary').checked = false;
            document.getElementById('periodicMode').checked = false;
            
            computeDelaunayVoronoi().then(() => {
                // Initialize demo visualizations after first computation
                setTimeout(() => {
                    createGeneratorMeshes();
                    createVectorArrows();
                    updateCentralCellColor();
                }, 100);
            });
            
            // Demo mode is always on
            demoMode = true;
            scene.background = new THREE.Color(0xcccccc);
            
            // Auto-select most central cell
            let minDistance = Infinity;
            let mostCentralIndex = 0;
            currentPoints.forEach((point, index) => {
                const distance = Math.sqrt(point[0]**2 + point[1]**2 + point[2]**2);
                if (distance < minDistance) {
                    minDistance = distance;
                    mostCentralIndex = index;
                }
            });
            centralCellIndex = mostCentralIndex;
            document.getElementById('centralCellIndex').value = centralCellIndex;
            
            // Store original positions
            originalPositions = currentPoints.map(p => [...p]);
            
            // Keep faces visible but no analysis coloring
            document.getElementById('showVoronoiFaces').checked = true;
            
            // Set up event listeners
            document.getElementById('showVertices').addEventListener('change', (e) => {
                verticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showDelaunay').addEventListener('change', (e) => {
                delaunayGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiVertices').addEventListener('change', (e) => {
                voronoiVerticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiEdges').addEventListener('change', (e) => {
                voronoiEdgesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showTetrahedra').addEventListener('change', (e) => {
                tetrahedraGroup.visible = e.target.checked;
            });
            
            document.getElementById('showBoundary').addEventListener('change', (e) => {
                boundaryGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiFaces').addEventListener('change', (e) => {
                voronoiFacesGroup.visible = e.target.checked;
            });
            

            
            document.getElementById('regenerate').addEventListener('click', () => {
                const numPoints = parseInt(document.getElementById('numPoints').value);
                const minDist = parseFloat(document.getElementById('minDistance').value);
                const usePoisson = document.getElementById('poissonSampling').checked;
                const points = usePoisson ? 
                    generatePoissonPoints(numPoints, minDist) : 
                    generateWellDistributedPoints(numPoints, minDist);
                currentPoints = points;
                velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                // Reset growth system if it exists
                if (growthSystem) {
                    growthSystem.reset();
                }
                computeDelaunayVoronoi();
            });
            
            document.getElementById('recompute').addEventListener('click', () => {
                computeDelaunayVoronoi();
            });
            
            document.getElementById('periodicMode').addEventListener('change', () => {
                computeDelaunayVoronoi();
            });
            
            // Growth System Controls - commented out since we removed these controls
            /*
            document.getElementById('enableGrowth').addEventListener('change', (e) => {
                growthEnabled = e.target.checked;
                if (growthEnabled) {
                    // Initialize growth system if not already done
                    if (!growthSystem) {
                        growthSystem = new GrowthSystem({
                            k: parseFloat(document.getElementById('growthRate').value),
                            damping: parseFloat(document.getElementById('growthDamping').value),
                            maxDelta: parseFloat(document.getElementById('growthMaxDelta').value),
                            threshold: parseFloat(document.getElementById('growthThreshold').value),
                            growthPower: parseFloat(document.getElementById('growthPower').value),
                            normalize: document.getElementById('growthNormalize').checked,
                            mode: document.getElementById('growthMode').value
                        });
                    }
                    // document.getElementById('growthStats').textContent = 'Dynamics active - waiting for data...';
                    
                    // Ensure cells mode is selected for growth to work
                    if (document.getElementById('faceCellMode').value === 'none') {
                        document.getElementById('faceCellMode').value = 'cells';
                        // Trigger analysis
                        if (computation) {
                            console.log('Triggering analysis for growth system...');
                            // Run analysis
                            if (currentPoints.length >= 500) {
                                if (!fastAnalyzer) {
                                    fastAnalyzer = new FastAcutenessAnalyzer();
                                }
                                analysisResults = fastAnalyzer.analyze(computation);
                            } else {
                                analysisResults = GeometryAnalysis.analyzeAcuteness(computation);
                            }
                            applyAnalysisColoring();
                        }
                    }
                } else {
                    // document.getElementById('growthStats').textContent = 'Dynamics inactive';
                }
            });
            
            document.getElementById('growthRate').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthRateValue').textContent = value.toFixed(4);
                if (growthSystem) {
                    growthSystem.updateConfig({ k: value });
                }
            });
            
            document.getElementById('growthDamping').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthDampingValue').textContent = value.toFixed(2);
                if (growthSystem) {
                    growthSystem.updateConfig({ damping: value });
                }
            });
            
            document.getElementById('growthMaxDelta').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthMaxDeltaValue').textContent = value.toFixed(3);
                if (growthSystem) {
                    growthSystem.updateConfig({ maxDelta: value });
                }
            });
            
            document.getElementById('growthThreshold').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthThresholdValue').textContent = value;
                if (growthSystem) {
                    growthSystem.updateConfig({ threshold: value });
                }
            });
            
            document.getElementById('growthMode').addEventListener('change', (e) => {
                if (growthSystem) {
                    growthSystem.updateConfig({ mode: e.target.value });
                }
            });
            
            document.getElementById('growthPower').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthPowerValue').textContent = value.toFixed(1);
                if (growthSystem) {
                    growthSystem.updateConfig({ growthPower: value });
                }
            });
            
            document.getElementById('growthNormalize').addEventListener('change', (e) => {
                if (growthSystem) {
                    growthSystem.updateConfig({ normalize: e.target.checked });
                }
            });
            
            document.getElementById('resetGrowth').addEventListener('click', () => {
                if (growthSystem) {
                    growthSystem.reset();
                    // document.getElementById('growthStats').textContent = growthEnabled ? 'Dynamics reset - waiting for data...' : 'Dynamics inactive';
                }
            });
            */
            
            // Demo mode controls
            // Removed showGenerators event listener since checkbox was removed
            
            // Removed showMovementVectors event listener since checkbox was removed
            
            document.getElementById('centralCellIndex').addEventListener('change', (e) => {
                centralCellIndex = parseInt(e.target.value);
                // Redraw faces to update colors
                drawVoronoiFaces(computation);
                createGeneratorMeshes();
                createVectorArrows();
                updateCentralCellColor();
            });
            
            document.getElementById('expansionSlider').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('expansionValue').textContent = value.toFixed(2);
                document.getElementById('expansionValue').style.color = 
                    value > 0 ? '#ff3333' : value < 0 ? '#0066ff' : '#666';
                
                // Apply expansion immediately
                applyDemoExpansion();
            });
            
            document.getElementById('resetDemo').addEventListener('click', () => {
                document.getElementById('expansionSlider').value = 0;
                document.getElementById('expansionValue').textContent = '0.00';
                document.getElementById('expansionValue').style.color = '#666';
                
                if (originalPositions.length > 0) {
                    currentPoints = originalPositions.map(p => [...p]);
                    createGeneratorMeshes();
                    computeDelaunayVoronoi();
                }
            });
            
            // Removed animateDemo event listener since button was removed
            
            document.getElementById('selectCentral').addEventListener('click', () => {
                if (currentPoints.length > 0) {
                    // Select a random cell
                    centralCellIndex = Math.floor(Math.random() * currentPoints.length);
                    document.getElementById('centralCellIndex').value = centralCellIndex;
                    // Redraw faces to update colors
                    drawVoronoiFaces(computation);
                    createGeneratorMeshes();
                    createVectorArrows();
                    updateCentralCellColor();
                }
            });
            
            // Removed updateDemo event listener since button was removed
            
            // Opacity slider event listeners
            document.getElementById('centralCellOpacity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('centralCellOpacityValue').textContent = value.toFixed(2);
                updateCentralCellColor();
            });
            
            document.getElementById('otherCellsOpacity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('otherCellsOpacityValue').textContent = value.toFixed(2);
                updateCentralCellColor();
            });
            
            // Size and color controls
            document.getElementById('delaunaySize').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('vertexColor').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('delaunayEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // NEW: Edge width controls
            document.getElementById('delaunayEdgeWidth').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // Handle reversed slider for voronoiSize
            const voronoiSizeSlider = document.getElementById('voronoiSize');
            const voronoiSizeValue = document.getElementById('voronoiSizeValue');
            
            function updateVoronoiSize() {
                // Convert reversed slider value to actual size
                const sliderValue = parseFloat(voronoiSizeSlider.value);
                const actualSize = 0.05 - sliderValue; // Reverse the value
                
                // Update display with 4 decimal places
                voronoiSizeValue.textContent = actualSize.toFixed(4);
                
                // Always redraw normal spheres first
                drawMeshes(computation);
                // Then reapply any active analysis
                applyAnalysisColoring();
            }
            
            voronoiSizeSlider.addEventListener('input', updateVoronoiSize);
            voronoiSizeSlider.addEventListener('change', updateVoronoiSize);
            
            document.getElementById('voronoiVertexColor').addEventListener('change', () => {
                // Always redraw normal spheres first
                drawMeshes(computation);
                // Then reapply any active analysis
                applyAnalysisColoring();
            });

            document.getElementById('voronoiEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // NEW: Voronoi edge width control
            document.getElementById('voronoiEdgeWidth').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // Face color and opacity controls
            document.getElementById('voronoiFaceColor').addEventListener('change', () => {
                drawVoronoiFaces(computation);
                createGhostCellTiling(); // Update ghost cells too
            });
            
            document.getElementById('voronoiFaceOpacity').addEventListener('change', () => {
                drawVoronoiFaces(computation);
                createGhostCellTiling(); // Update ghost cells too
            });
            
            document.getElementById('tetraColor').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            document.getElementById('tetraOpacity').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            // NEW: Event listeners for MIC and Ghost Cell controls
            document.getElementById('useMIC').addEventListener('change', () => {
                drawMeshes(computation);
                createGhostCellTiling();
            });
            
            document.getElementById('showGhostCells').addEventListener('change', () => {
                createGhostCellTiling();
            });
            

            
            // NEW: Control panel toggle
            document.getElementById('controls-toggle').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const toggle = document.getElementById('controls-toggle');
                const content = document.getElementById('controls-content');
                const legends = document.querySelectorAll('.acuteness-legend');
                
                if (controls.classList.contains('hidden')) {
                    controls.classList.remove('hidden');
                    content.style.display = 'block';
                    toggle.textContent = 'hide';
                    toggle.title = 'Hide Controls';
                    // Show legends
                    legends.forEach(legend => {
                        legend.style.display = 'block';
                    });
                } else {
                    controls.classList.add('hidden');
                    content.style.display = 'none';
                    toggle.textContent = 'show';
                    toggle.title = 'Show Controls';
                    // Hide legends
                    legends.forEach(legend => {
                        legend.style.display = 'none';
                    });
                }
            });
            
            // Background color control
            document.getElementById('backgroundColor').addEventListener('change', (e) => {
                scene.background = new THREE.Color(e.target.value);
            });
            
            // Removed all acuteness analysis event listeners since controls were removed
            




            animate();
            
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 