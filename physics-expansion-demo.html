<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics-Based Voronoi Cell Expansion Demo</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            width: 320px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ddd;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        .value-display {
            min-width: 50px;
            text-align: right;
            font-family: monospace;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:active {
            background: #3d8b40;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }
        
        .info-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .info-label {
            color: #aaa;
        }
        
        .info-value {
            color: #fff;
            font-weight: bold;
        }
        
        .highlight {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h3 style="margin-top: 0;">Physics-Based Cell Expansion</h3>
        
        <div class="control-group">
            <label>Expansion Mode:</label>
            <select id="expansionMode" style="width: 100%; padding: 5px;">
                <option value="single">Single Cell (Central)</option>
                <option value="multiple">Multiple Cells</option>
                <option value="pattern">Pattern-Based</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Growth Rate:</label>
            <div class="slider-container">
                <input type="range" id="growthRate" min="-2" max="2" step="0.1" value="0">
                <span class="value-display" id="growthRateValue">0.0</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Force Strength:</label>
            <div class="slider-container">
                <input type="range" id="forceStrength" min="0" max="1" step="0.01" value="0.5">
                <span class="value-display" id="forceStrengthValue">0.50</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Damping:</label>
            <div class="slider-container">
                <input type="range" id="damping" min="0" max="1" step="0.01" value="0.8">
                <span class="value-display" id="dampingValue">0.80</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Visualization:</label>
            <div class="checkbox-group">
                <input type="checkbox" id="showGenerators" checked>
                <label for="showGenerators">Generators</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showForces" checked>
                <label for="showForces">Force Vectors</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showCells" checked>
                <label for="showCells">Voronoi Cells</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showGrid" checked>
                <label for="showGrid">Grid</label>
            </div>
        </div>
        
        <button id="resetButton">Reset Positions</button>
        <button id="pauseButton">Pause Animation</button>
    </div>
    
    <div id="info">
        <h4 style="margin-top: 0;">Statistics</h4>
        <div class="info-item">
            <span class="info-label">Total Cells:</span>
            <span class="info-value" id="totalCells">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Growing Cells:</span>
            <span class="info-value highlight" id="growingCells">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">Average Force:</span>
            <span class="info-value" id="avgForce">0.00</span>
        </div>
        <div class="info-item">
            <span class="info-label">Max Displacement:</span>
            <span class="info-value" id="maxDisplacement">0.00</span>
        </div>
    </div>

    <!-- Three.js and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js"></script>
    
    <script type="module">
        // Import necessary modules
        import { DelaunayComputation } from './src/js/DelaunayComputation.js';
        import { PhysicsExpansion } from './src/js/PhysicsExpansion.js';
        
        // Initialize Three.js scene
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        camera.position.set(0, 0, 2.5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(3, 30, 0x444444, 0x222222);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
        
        // State variables
        let generatorPoints = [];
        let generatorMeshes = [];
        let voronoiCells = [];
        let cellMeshes = [];
        let forceArrows = [];
        let computation = null;
        let physicsEngine = null;
        let isPaused = false;
        let originalPositions = [];
        
        // Growing cells tracking
        const growingCells = new Set();
        
        // Create initial points in a hexagonal pattern
        function createHexagonalPoints(rings = 3) {
            const points = [];
            const spacing = 0.25;
            
            // Center point
            points.push([0, 0, 0]);
            
            // Create rings
            for (let ring = 1; ring <= rings; ring++) {
                const numPoints = ring * 6;
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const radius = ring * spacing;
                    const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.02;
                    const y = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.02;
                    const z = (Math.random() - 0.5) * 0.05;
                    points.push([x, y, z]);
                }
            }
            
            return points;
        }
        
        // Create generator point meshes
        function createGeneratorMeshes() {
            // Clear existing meshes
            generatorMeshes.forEach(mesh => scene.remove(mesh));
            generatorMeshes = [];
            
            if (!document.getElementById('showGenerators').checked) return;
            
            const geometry = new THREE.SphereGeometry(0.015, 16, 16);
            
            generatorPoints.forEach((point, index) => {
                const isGrowing = growingCells.has(index);
                const material = new THREE.MeshBasicMaterial({
                    color: isGrowing ? 0xff4444 : 0x4444ff
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(point[0], point[1], point[2]);
                scene.add(mesh);
                generatorMeshes.push(mesh);
            });
        }
        
        // Create Voronoi cell meshes
        function createCellMeshes() {
            // Clear existing meshes
            cellMeshes.forEach(mesh => scene.remove(mesh));
            cellMeshes = [];
            
            if (!document.getElementById('showCells').checked) return;
            
            voronoiCells.forEach((cell, index) => {
                if (cell.length < 4) return; // Skip degenerate cells
                
                // Create geometry from cell vertices
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];
                
                // Add vertices
                cell.forEach(vertex => {
                    vertices.push(vertex[0], vertex[1], vertex[2]);
                });
                
                // Create simple triangulation (works for convex cells)
                for (let i = 1; i < cell.length - 1; i++) {
                    indices.push(0, i, i + 1);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const isGrowing = growingCells.has(index);
                const material = new THREE.MeshBasicMaterial({
                    color: isGrowing ? 0xff6666 : 0x6666ff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: false
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                cellMeshes.push(mesh);
                
                // Add wireframe
                const wireframeGeometry = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: isGrowing ? 0xff0000 : 0x0000ff,
                    linewidth: 2
                });
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                scene.add(wireframe);
                cellMeshes.push(wireframe);
            });
        }
        
        // Create force visualization arrows
        function createForceArrows() {
            // Clear existing arrows
            forceArrows.forEach(arrow => scene.remove(arrow));
            forceArrows = [];
            
            if (!document.getElementById('showForces').checked || !physicsEngine) return;
            
            const forceVectors = physicsEngine.getForceVectors();
            
            forceVectors.forEach(({ index, force, magnitude }) => {
                if (index >= generatorPoints.length) return;
                
                const point = generatorPoints[index];
                const origin = new THREE.Vector3(point[0], point[1], point[2]);
                const direction = new THREE.Vector3(force.x, force.y, force.z).normalize();
                const length = Math.min(magnitude * 10, 0.3); // Scale for visibility
                
                const arrowHelper = new THREE.ArrowHelper(
                    direction,
                    origin,
                    length,
                    0xffff00,
                    length * 0.3,
                    length * 0.2
                );
                
                scene.add(arrowHelper);
                forceArrows.push(arrowHelper);
            });
        }
        
        // Update visualization
        function updateVisualization() {
            // Update generator positions
            generatorMeshes.forEach((mesh, index) => {
                if (index < generatorPoints.length) {
                    const point = generatorPoints[index];
                    mesh.position.set(point[0], point[1], point[2]);
                    
                    // Update color based on growth status
                    const isGrowing = growingCells.has(index);
                    mesh.material.color.setHex(isGrowing ? 0xff4444 : 0x4444ff);
                }
            });
            
            // Recreate cell meshes and force arrows
            createCellMeshes();
            createForceArrows();
        }
        
        // Initialize Voronoi computation
        async function initializeVoronoi() {
            // Load WASM module
            const wasmModule = await fetch('./dist/periodic_delaunay.wasm')
                .then(response => response.arrayBuffer());
            
            // Create initial points
            generatorPoints = createHexagonalPoints(3);
            originalPositions = generatorPoints.map(p => [...p]);
            
            // Initialize physics engine
            physicsEngine = new PhysicsExpansion();
            
            // Create computation
            computation = new DelaunayComputation(generatorPoints, false);
            await computation.compute(wasmModule);
            
            // Get Voronoi cells
            voronoiCells = computation.getCells();
            
            // Create visualizations
            createGeneratorMeshes();
            createCellMeshes();
            
            // Update stats
            updateStats();
        }
        
        // Recompute Voronoi after point movement
        async function recomputeVoronoi() {
            if (!computation) return;
            
            computation.points = generatorPoints;
            await computation.recompute();
            voronoiCells = computation.getCells();
        }
        
        // Update growth rates based on UI
        function updateGrowthRates() {
            if (!physicsEngine) return;
            
            const mode = document.getElementById('expansionMode').value;
            const growthRate = parseFloat(document.getElementById('growthRate').value);
            
            physicsEngine.clearGrowthRates();
            growingCells.clear();
            
            if (Math.abs(growthRate) < 0.001) return;
            
            switch (mode) {
                case 'single':
                    // Only central cell grows
                    const centralIndex = Math.floor(generatorPoints.length / 2);
                    physicsEngine.setGrowthRate(centralIndex, growthRate);
                    growingCells.add(centralIndex);
                    break;
                    
                case 'multiple':
                    // Multiple random cells grow
                    const numGrowing = Math.floor(generatorPoints.length * 0.3);
                    for (let i = 0; i < numGrowing; i++) {
                        const index = Math.floor(Math.random() * generatorPoints.length);
                        physicsEngine.setGrowthRate(index, growthRate);
                        growingCells.add(index);
                    }
                    break;
                    
                case 'pattern':
                    // Alternating pattern
                    generatorPoints.forEach((point, index) => {
                        // Checkerboard pattern based on position
                        const x = Math.floor(point[0] * 4);
                        const y = Math.floor(point[1] * 4);
                        if ((x + y) % 2 === 0) {
                            physicsEngine.setGrowthRate(index, growthRate);
                            growingCells.add(index);
                        }
                    });
                    break;
            }
            
            updateStats();
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('totalCells').textContent = generatorPoints.length;
            document.getElementById('growingCells').textContent = growingCells.size;
        }
        
        // Animation loop
        async function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // Apply physics if not paused
            if (!isPaused && physicsEngine && Math.abs(parseFloat(document.getElementById('growthRate').value)) > 0.001) {
                // Update physics parameters
                physicsEngine.forceStrength = parseFloat(document.getElementById('forceStrength').value);
                physicsEngine.damping = parseFloat(document.getElementById('damping').value);
                
                // Apply physics step
                const result = physicsEngine.applyPhysicsStep(generatorPoints, voronoiCells);
                generatorPoints = result.updatedPoints;
                
                // Update stats
                document.getElementById('avgForce').textContent = result.averageForce.toFixed(3);
                document.getElementById('maxDisplacement').textContent = result.maxDisplacement.toFixed(3);
                
                // Recompute Voronoi
                await recomputeVoronoi();
                
                // Update visualization
                updateVisualization();
            }
            
            renderer.render(scene, camera);
        }
        
        // Event listeners
        document.getElementById('growthRate').addEventListener('input', (e) => {
            document.getElementById('growthRateValue').textContent = parseFloat(e.target.value).toFixed(1);
            updateGrowthRates();
        });
        
        document.getElementById('forceStrength').addEventListener('input', (e) => {
            document.getElementById('forceStrengthValue').textContent = parseFloat(e.target.value).toFixed(2);
        });
        
        document.getElementById('damping').addEventListener('input', (e) => {
            document.getElementById('dampingValue').textContent = parseFloat(e.target.value).toFixed(2);
        });
        
        document.getElementById('expansionMode').addEventListener('change', updateGrowthRates);
        
        document.getElementById('showGenerators').addEventListener('change', createGeneratorMeshes);
        document.getElementById('showCells').addEventListener('change', createCellMeshes);
        document.getElementById('showForces').addEventListener('change', createForceArrows);
        document.getElementById('showGrid').addEventListener('change', (e) => {
            gridHelper.visible = e.target.checked;
        });
        
        document.getElementById('resetButton').addEventListener('click', () => {
            generatorPoints = originalPositions.map(p => [...p]);
            physicsEngine.reset();
            updateGrowthRates();
            updateVisualization();
        });
        
        document.getElementById('pauseButton').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseButton').textContent = isPaused ? 'Resume Animation' : 'Pause Animation';
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize and start
        initializeVoronoi().then(() => {
            updateGrowthRates();
            animate();
        });
    </script>
</body>
</html> 